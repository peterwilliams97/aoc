# Advent of Code 2024 Solutions

This repository contains Python solutions for the Advent of Code 2024 challenges.
           Below is a brief description of each day's problem and solution.

This docuement generated by the [readme.py](summarisers/readme.py) script.
        25 Python solutions were analysed.

### Day 1: Comparing Lists ([aoc2024-day1.py](aoc2024-day1.py))
- **Problem 1**: Calculate the sum of absolute differences between corresponding elements in two lists.
- **Problem 2**: Calculate a total similarity score by adding up each number in the left list after multiplying it by the number of times that number appears in the right list.
- **Solution 1**: Reads input lines as pairs of numbers, transposes the pairs into two columns, calculates the absolute difference between corresponding elements in the columns, and sums the differences.
- **Solution 2**: Reads input lines as pairs of numbers, transposes the pairs into two columns, counts the occurrences of each number in the right column, multiplies each number in the left column by its count in the right column, and sums the products.

### Day 2: Reactor Safety Report Validation ([aoc2024-day2.py](aoc2024-day2.py))
- **Problem 1**: Determine if a report's levels are either all increasing or all decreasing, with adjacent levels differing by at most 3. Count the number of valid reports.
- **Problem 2**: If removing a single level from an invalid report would make it valid, count that report as valid. Count the number of valid reports with this relaxed rule.
- **Solution 1**: Calculates the differences between adjacent levels, checks if all differences are positive (increasing) or negative (decreasing), and that the absolute differences are between 1 and 3.
- **Solution 2**: Iterates through each level in an invalid report, removes it, and checks if the remaining report is valid using the Part 1 solution. If any removal results in a valid report, it is counted as valid.

### Day 3: Corrupted Memory Processing ([aoc2024-day3.py](aoc2024-day3.py))
- **Problem 1**: Identify valid multiplication instructions (mul(a,b)) in a given text and calculate the sum of their products.
- **Problem 2**: Introduce new instructions do() and don't() that enable or disable future mul instructions. Only the most recent do() or don't() instruction applies. At the beginning, mul instructions are enabled. Calculate the sum of products for enabled mul instructions only.
- **Solution 1**: Uses a regular expression to find patterns of the form mul(a,b), extracts the numbers a and b, multiplies them, and sums the products.
- **Solution 2**: Uses another regular expression to find do() and don't() instructions. Splits the text into spans based on these instructions. Applies the Part 1 solution to each span where mul instructions are enabled, and sums the results.

### Day 4: Word Search Puzzles ([aoc2024-day4.py](aoc2024-day4.py))
- **Problem 1**: Find the number of occurrences of the word 'XMAS' in a given word search grid.
- **Problem 2**: Find the number of 'X' shapes formed by 'MAS' words in the word search grid, where each 'MAS' can be read forwards or backwards.
- **Solution 1**: Iterates through all 'X' positions, checks for 'M', 'A', 'S' in the 8 surrounding directions, and counts valid 'XMAS' occurrences.
- **Solution 2**: Iterates through all 'A' positions, checks for 'M' and 'S' in the two diagonal directions forming an 'X', and counts valid 'X' shapes.

### Day 5: Page Ordering Rules ([aoc2024-day5.py](aoc2024-day5.py))
- **Problem 1**: Given a set of page ordering rules and a list of updates (each containing a sequence of page numbers), find the correctly ordered updates and calculate the sum of the middle page numbers.
- **Problem 2**: For the incorrectly ordered updates, reorder the page numbers according to the rules and find the sum of the middle page numbers in the reordered updates.
- **Solution 1**: Parses the input into rules and updates. Checks if each update obeys the rules by iterating through the pages and checking if any preceding page should come after the current page according to the rules. Finds the valid updates, extracts the middle page number from each, and sums them.
- **Solution 2**: Identifies the invalid updates, reorders each one by swapping pages that violate the rules until the update is valid, extracts the middle page number from each reordered update, and sums them.

### Day 6: Guard Gallivant ([aoc2024-day6.py](aoc2024-day6.py))
- **Problem 1**: Predict the path of a guard following a strict patrol protocol on a map with obstacles, and determine how many distinct positions the guard will visit before leaving the mapped area.
- **Problem 2**: Find all possible positions where a single new obstruction can be placed to cause the guard to get stuck in a loop, avoiding the guard's starting position.
- **Solution 1**: Parses the input map, simulates the guard's movement following the protocol, and counts the number of distinct positions visited before the guard leaves the mapped area.
- **Solution 2**: Performs a breadth-first search from the guard's starting position, trying all possible obstruction placements and checking if the guard gets stuck in a loop using a recursive function. Counts the number of positions where an obstruction would cause a loop.

### Day 7: Equation Evaluation ([aoc2024-day7.py](aoc2024-day7.py))
- **Problem 1**: Given a list of equations with a target value and a sequence of numbers, determine which equations can be made true by combining the numbers using addition and multiplication operators, evaluated left-to-right.
- **Problem 2**: Same as Part 1, but with an additional operator that concatenates numbers.
- **Solution 1**: Parses the input equations into target values and number sequences. Uses a recursive function to try all possible combinations of addition and multiplication operators on the number sequences, evaluating left-to-right. Returns the sum of target values for valid equations.
- **Solution 2**: Similar to Part 1, but adds the concatenation operator to the list of allowed operators in the recursive function.

### Day 8: Antenna Antinodes ([aoc2024-day8.py](aoc2024-day8.py))
- **Problem 1**: Identify the grid positions that are antinodes, which occur at points perfectly in line with two antennas of the same frequency, where one antenna is twice as far away as the other.
- **Problem 2**: Antinodes now occur at any grid position exactly in line with at least two antennas of the same frequency, regardless of distance.
- **Solution 1**: Iterates over pairs of antenna positions, calculates the line between them, and marks grid positions along that line as antinodes, excluding positions that are also in line with antennas of different frequencies.
- **Solution 2**: Similar to Part 1, but marks all grid positions along the line between any pair of antennas with the same frequency as antinodes, without the distance constraint.

### Day 9: Disk File Compaction ([aoc2024-day9.py](aoc2024-day9.py))
- **Problem 1**: Compact a disk map by moving file blocks to the leftmost free space, one block at a time, and calculate the resulting filesystem checksum.
- **Problem 2**: Compact the disk map by moving entire files to the leftmost span of free space that can fit them, in decreasing order of file ID. Calculate the resulting filesystem checksum.
- **Solution 1**: Iterates through the disk map from both ends, moving file blocks to the left by swapping them with free space blocks. Calculates the checksum by multiplying each block's position with its file ID and summing the results.
- **Solution 2**: Represents the disk map as a list of runs (clusters of file blocks and gaps of free space). Iterates through the runs in reverse order, attempting to move each cluster to the leftmost gap that can fit it. Calculates the checksum as in Part 1.

### Day 10: Hiking Trail Scoring ([aoc2024-day10.py](aoc2024-day10.py))
- **Problem 1**: Given a topographic map with heights from 0 to 9, calculate the sum of scores for all trailheads (positions with height 0). A trailhead's score is the number of positions with height 9 reachable from that trailhead via a hiking trail.
- **Problem 2**: Calculate the sum of ratings for all trailheads, where a trailhead's rating is the number of distinct hiking trails of length 18 (9*2) that start at that trailhead and visit all heights from 0 to 9.
- **Solution 1**: Implements a recursive function trailhead_destinations() that explores all paths starting from a trailhead and counts the number of destinations with height 9.
- **Solution 2**: Implements a recursive function complete_trails() that explores all paths starting from a trailhead and counts the number of distinct trails of length 18 that visit all heights from 0 to 9.

### Day 11: Blinking Stones ([aoc2024-day11.py](aoc2024-day11.py))
- **Problem 1**: Given a list of numbers engraved on stones, apply a set of rules to transform the numbers after blinking 25 times. The rules involve replacing numbers with new numbers based on certain conditions. Count the total number of stones after 25 blinks.
- **Problem 2**: Same as Part 1, but count the total number of stones after 75 blinks.
- **Solution 1**: Iterates over the list of numbers 25 times, applying the rules to each number using the apply_rule() function and creating a new list with the transformed numbers using blink_once().
- **Solution 2**: Uses a cache to store the results of applying the rules to each number. Maintains a dictionary of {number: count} to keep track of the number of occurrences of each number. Applies the rules using blink_once_cache() which updates the dictionary based on the cached results. Sums the counts in the final dictionary to get the total number of stones.

### Day 12: Garden Plot Fencing ([aoc2024-day12.py](aoc2024-day12.py))
- **Problem 1**: Given a map of garden plots where each plot grows a single type of plant, calculate the total cost of fencing all regions of connected plots of the same plant type. The cost is the area of a region multiplied by its perimeter.
- **Problem 2**: Instead of using the perimeter to calculate the fencing cost, use the number of straight sections (sides) required to fence each region, regardless of length.
- **Solution 1**: The code identifies connected components of the same plant type, calculates the area and perimeter of each region, and sums the products of area and perimeter across all regions.
- **Solution 2**: The code identifies the sides of each connected component that are not shared with another component, counts the number of such sides for each component, and sums the products of area and number of sides across all components.

### Day 13: Claw Machine Prize Positioning ([aoc2024-day13.py](aoc2024-day13.py))
- **Problem 1**: Given the button presses and prize locations for multiple claw machines, find the minimum number of tokens required to win all possible prizes.
- **Problem 2**: The prize locations were incorrectly measured, and are actually 10000000000000 higher on both X and Y axes. Find the minimum number of tokens required to win all possible prizes with the corrected locations.
- **Solution 1**: Parses the input data, solves the linear equations for each machine to find the required button presses, and sums the costs for all machines where a solution exists.
- **Solution 2**: Adds 10000000000000 to the X and Y coordinates of each prize location, then uses the same approach as Part 1 to solve the linear equations and sum the costs for machines with solutions.

### Day 14: Restroom Redoubt ([aoc2024-day14.py](aoc2024-day14.py))
- **Problem 1**: Predict the motion of robots in a 101x103 tile space after 100 seconds have elapsed, and calculate the safety factor by multiplying the number of robots in each quadrant.
- **Problem 2**: Find the fewest number of seconds for the robots to arrange themselves into a picture of a Christmas tree, which is a hard-coded Easter egg.
- **Solution 1**: Parses the input to get robot positions and velocities. Simulates the robot motion for 100 seconds, wrapping around edges. Counts the number of robots in each quadrant and multiplies them together to get the safety factor.
- **Solution 2**: Simulates the robot motion, checking at each step if the robots form a Christmas tree pattern. A tree pattern is defined as having few robots in the corners and a contiguous 3x3 block of robots. Outputs the first time step where a tree pattern is found.

### Day 15: Warehouse Robot Movement Simulation ([aoc2024-day15.py](aoc2024-day15.py))
- **Problem 1**: Simulate the movement of a robot in a warehouse with boxes, following a given sequence of moves. Calculate the sum of GPS coordinates of all boxes after the robot finishes moving.
- **Problem 2**: Simulate the movement of the robot in a scaled-up warehouse where boxes are twice as wide. Calculate the sum of GPS coordinates of all boxes after the robot finishes moving in this scaled-up warehouse.
- **Solution 1**: Represents the warehouse as a 2D numpy array, with values for walls, spaces, boxes, and the robot. Implements functions to parse the input, move the robot and boxes according to the rules, and calculate the sum of box coordinates.
- **Solution 2**: Extends the Part 1 solution to handle wide boxes represented by pairs of values in the grid. Implements functions to validate the scaled-up grid, move wide boxes according to the rules, and calculate the sum of box coordinates in the scaled-up warehouse.

### Day 16: Reindeer Maze Navigation ([aoc2024-day16.py](aoc2024-day16.py))
- **Problem 1**: Find the lowest score a reindeer can achieve while navigating through a maze from the start tile to the end tile, where moving forward incurs a penalty of 1 and turning 90 degrees incurs a penalty of 1000.
- **Problem 2**: Determine how many tiles in the maze are part of at least one of the best paths found in Part 1.
- **Solution 1**: Uses Uniform Cost Search with a priority queue to find the least costly paths through the maze, keeping track of visited states and predecessors. Returns the minimum score among all least costly paths.
- **Solution 2**: Extends the Part 1 solution to reconstruct and count the unique tiles visited in the least costly paths, either by storing all paths or just the visited tiles to optimize memory usage.

### Day 17: Chronospatial Computer ([aoc2024-day17.py](aoc2024-day17.py))
- **Problem 1**: Determine the output of a program running on a 3-bit computer with 8 instructions and 3 registers (A, B, C). The program is given as a list of 3-bit numbers representing opcodes and operands.
- **Problem 2**: Find the lowest positive initial value for register A that causes the program to output an exact copy of itself.
- **Solution 1**: Parses the input to extract the program and initial register values. Implements an execute_program function that simulates the 8 instructions using the given operands and register values. Outputs the result by joining the values produced by the OUT instruction.
- **Solution 2**: Implements a depth-first search (dfs) function that recursively searches for the value of register A that produces the given program as output. The search is guided by the observation that the output is the low 3 bits of register A shifted left by 3 bits and possibly XORed with constants or other registers.

### Day 18: RAM Run ([aoc2024-day18.py](aoc2024-day18.py))
- **Problem 1**: Simulate the first 1024 bytes falling onto a 71x71 memory space grid, where you start at (0,0) and need to reach the exit at (70,70). Corrupted coordinates cannot be entered. Find the minimum number of steps needed to reach the exit.
- **Problem 2**: Determine the coordinates of the first byte that will prevent the exit from being reachable from the starting position (0,0).
- **Solution 1**: Creates a 2D grid representing the memory space. Marks the positions of the falling bytes as walls. Uses Uniform Cost Search with a priority queue to find the shortest path from (0,0) to (70,70), avoiding walls. Returns the length of the shortest path.
- **Solution 2**: Builds the grid as in Part 1. Finds the initial shortest path to the exit. Then iterates through the remaining bytes, temporarily marking each one as a wall. If this makes the exit unreachable, that byte's coordinates are the answer. Returns the coordinates of the first such byte.

### Day 19: Towel Arrangement ([aoc2024-day19.py](aoc2024-day19.py))
- **Problem 1**: Given a list of available towel patterns (sequences of colored stripes) and a list of desired designs (sequences of colored stripes), determine how many of the desired designs can be created by combining the available towel patterns.
- **Problem 2**: For each desired design that can be constructed, count the number of different ways it can be constructed by combining the available towel patterns.
- **Solution 1**: Uses a depth-first search with memoization to check if each desired design can be constructed by concatenating available towel patterns. Counts the number of designs that can be constructed.
- **Solution 2**: Extends the depth-first search from Part 1 to also count the number of different ways each valid design can be constructed. Sums these counts across all valid designs.

### Day 20: Race Condition Festival ([aoc2024-day20.py](aoc2024-day20.py))
- **Problem 1**: Find the number of cheats that save at least 100 picoseconds in a race condition festival where programs can cheat for up to 2 picoseconds by passing through walls.
- **Problem 2**: Find the number of cheats that save at least 100 picoseconds in the updated rules where a single cheat lasting up to 20 picoseconds is allowed.
- **Solution 1**: Uses Uniform Cost Search to find the shortest path through the maze. Identifies potential cheats by finding wall cells adjacent to the path that could be skipped. Counts the number of cheats that save at least 100 picoseconds.
- **Solution 2**: Uses the same approach as Part 1, but identifies potential cheats as sequences of up to 20 cells that could be skipped. Counts the number of cheats that save at least 100 picoseconds.

### Day 21: Keypad Conundrum ([aoc2024-day21.py](aoc2024-day21.py))
- **Problem 1**: Find the fewest number of button presses needed to cause a robot to type five given codes on a numeric keypad, where the robot is controlled by a chain of two directional keypads.
- **Problem 2**: Same as Part 1, but with a chain of 25 directional keypads controlling the robot typing on the numeric keypad.
- **Solution 1**: Calculates the shortest sequence of directional keypad presses to type each numeric code, using a recursive function and caching intermediate results. Computes the complexity of each code as the product of the number of presses and the numeric part of the code, and returns the sum of complexities.
- **Solution 2**: Uses the same approach as Part 1, but with a longer chain of robots and directional keypads.

### Day 22: Monkey Market ([aoc2024-day22.py](aoc2024-day22.py))
- **Problem 1**: Each buyer on the Monkey Exchange Market uses a secret number sequence to determine their prices. Given the initial secret numbers for each buyer, simulate the creation of 2000 new secret numbers for each buyer and find the sum of the 2000th secret number generated by each buyer.
- **Problem 2**: Instead of using the secret numbers directly as prices, the buyers use the ones digit of each secret number as their price. The goal is to find the sequence of four consecutive price changes that will maximize the total number of bananas obtained by selling to each buyer when that sequence is observed.
- **Solution 1**: The code defines a function secret_number_ that calculates the next secret number in the sequence using a series of mixing and pruning operations. It then runs a simulation for each initial secret number, generating 2000 new secret numbers and summing the 2000th number across all buyers.
- **Solution 2**: The code defines classes to represent banana prices and price change sequences. It simulates the price changes for each buyer over 2000 iterations, tracking all possible sequences of four consecutive changes. It then finds the sequence that maximizes the total number of bananas obtained by selling when that sequence is first observed for each buyer.

### Day 23: LAN Party ([aoc2024-day23.py](aoc2024-day23.py))
- **Problem 1**: Find the number of sets of three inter-connected computers where at least one computer's name starts with 't'.
- **Problem 2**: Find the largest set of computers that are all connected to each other. The password is the sorted, comma-joined names of computers in this set.
- **Solution 1**: Constructs an adjacency list graph from the input connections. Finds all triplets of connected computers and counts those containing a 't' computer.
- **Solution 2**: Uses the Bron-Kerbosch algorithm to find all maximal cliques (fully connected subsets) in the graph. Returns the largest such clique as the password.

### Day 24: Crossed Wires Logic Gate Simulation ([aoc2024-day24.py](aoc2024-day24.py))
- **Problem 1**: Simulate a system of logic gates (AND, OR, XOR) connected by wires to produce a binary number on wires starting with 'z'.
- **Problem 2**: The system is supposed to add two binary numbers represented on 'x' and 'y' wires. However, four pairs of gate outputs are swapped. Identify the eight wires involved in the swaps so the system correctly performs addition.
- **Solution 1**: Parses the input into wire values and gate connections. Evaluates the gates by propagating values through the wires until all 'z' wires have a value. Converts the 'z' wire values to a decimal number.
- **Solution 2**: Checks if the gate connections follow rules for a ripple-carry adder circuit used for binary addition. Identifies wires connected to gates violating the rules as the incorrect outputs that need to be swapped.

### Day 25: Virtual Lock and Key Fitting ([aoc2024-day25.py](aoc2024-day25.py))
- **Problem 1**: Given schematics of virtual locks and keys, determine how many unique lock/key pairs fit together without overlapping in any column.
- **Problem 2**: No Part 2 problem description provided.
- **Solution 1**: Converts lock and key schematics to lists of heights, then checks if each key's heights are greater than or equal to the corresponding lock's heights for all columns.
- **Solution 2**: No Part 2 solution provided.


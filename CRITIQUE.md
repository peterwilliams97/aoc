# Advent of Code 2024 Python Solutions Critique

This document provides a critique of the Python solutions for Advent of Code 2024.
            It was generated by the [critique.py](summarisers/critique.py) script.

23 Python solutions were analysed.

## Overall

_The provided solutions demonstrate a strong understanding of Python programming and algorithmic problem-solving. The codebase showcases effective use of data structures, algorithms, and Python features like list comprehensions and functional programming techniques. The modular design and separation of concerns contribute to code readability and maintainability. However, there are opportunities for improvement in areas such as code documentation, error handling, performance optimization, and memory management. With focused effort on addressing these areas, the codebase can become more robust, efficient, and maintainable, further enhancing the developer's skills and ability to tackle complex problems._

**Overall Score**: 8/10

**Main Strength**:
1. Good understanding of Python data structures and built-in functions
1. Effective use of modular design and separation of concerns
1. Clever application of algorithms like Dijkstra's, A* search, and depth-first search
1. Utilization of caching and memoization techniques for performance optimization
1. Well-structured and readable code with meaningful variable names
1. Inclusion of test cases and timing information for performance analysis

**Main Weaknesses**:
1. Lack of comments and docstrings in some solutions, hindering code readability and maintainability
1. Limited error handling and input validation, reducing robustness
1. Potential performance issues for large inputs due to inefficient algorithms or data structures
1. Hardcoded constants and magic numbers, making the code less configurable
1. Occasional code duplication and repetitive logic

**Main Issues**:
1. Recursive approaches in some solutions could lead to stack overflow for large inputs
1. Nested loops and inefficient data structures in certain functions, impacting performance
1. Memory-intensive operations like creating copies of grids or storing entire paths
1. Potential integer overflow or precision issues when dealing with large numbers

**Areas for Improvement**:
1. Improve code documentation with comments and docstrings for better readability and maintainability
1. Implement robust error handling and input validation to handle edge cases and invalid inputs
1. Optimize algorithms and data structures for better performance on large inputs
1. Refactor code to eliminate code duplication and improve modularity
1. Explore alternative approaches or data structures for memory-intensive operations
1. Consider using constants or configuration files for hardcoded values

## Files Analyzed

### Day 1: [aoc2024-day1.py](aoc2024-day1.py)

**Score**: 7/10

**Strengths**:
- Clear separation of concerns with separate functions for Part 1 and Part 2.
- Effective use of Python's built-in functions (zip, sorted, abs, etc.).
- Good use of list comprehensions and functional programming techniques.
- Well-structured and readable code with meaningful variable names.
- Inclusion of timing information for performance analysis.

**Weaknesses**:
- Lack of comments explaining the logic or purpose of the functions.
- No error handling or input validation.
- Hardcoded test input file path.

**Issues**:
- The part1 function could potentially be optimized further by avoiding unnecessary sorting.
- The part2 function could be made more memory-efficient by avoiding the creation of a separate list for columns.

### Day 2: [aoc2024-day2.py](aoc2024-day2.py)

**Score**: 7/10

**Strengths**:
- Clear separation of concerns with separate functions for different tasks.
- Effective use of Python data structures and built-in functions (e.g. zip, list comprehensions).
- Good use of helper functions (diff_, pos_neg, is_valid_, is_valid_tol).
- Well-structured and readable code with meaningful variable names.
- Handles both parts of the problem in separate functions.
- Includes test input and common utility functions.

**Weaknesses**:
- Lack of comments explaining the purpose and logic of some functions (e.g. diff_, pos_neg).
- No error handling or input validation for malformed input lines.
- No performance optimizations or consideration for large inputs.
- Potential for code duplication between is_valid_() and is_valid_tol().

**Issues**:
- In is_valid_tol(): The nested loop to check subrows could be inefficient for large inputs.
- In part1() and part2(): No error handling for empty input or non-numeric values.

### Day 3: [aoc2024-day3.py](aoc2024-day3.py)

**Score**: 7/10

**Strengths**:
- Clear separation of concerns with separate functions for Part 1 and Part 2.
- Effective use of regular expressions to parse the input string.
- Good use of list comprehensions and generator expressions.
- Well-structured and readable code with meaningful variable names.
- Modular design with helper functions like sum_total() and spans_().

**Weaknesses**:
- Lack of error handling for invalid input formats.
- No comments or docstrings explaining the purpose and logic of functions.
- Potential performance issues for very large input strings due to the use of regular expressions.

**Issues**:
- In sum_total(): The use of re.finditer() and regular expressions could be inefficient for very large input strings.
- In spans_(): The function could potentially be optimized for better performance, especially for inputs with many 'do()' and 'don't()' instructions.

### Day 4: [aoc2024-day4.py](aoc2024-day4.py)

**Score**: 7/10

**Strengths**:
- Clear separation of concerns with separate functions for Part 1 and Part 2
- Effective use of helper functions (char_positions) and list comprehensions
- Clever generation of offsets to check for 'XMAS' sequences in Part 1
- Efficient checking of diagonal directions in Part 2
- Good use of comments to explain the purpose of each function

**Weaknesses**:
- Lack of error handling for invalid inputs (e.g. missing characters, empty grid)
- Potential performance issues for very large grids due to nested loops
- Limited reusability of the code for different problem variations
- Lack of test cases or examples to verify correctness

**Issues**:
- In part1: The nested loops and offset generation could be optimized for better performance.
- In part2: The diagonal direction checking could be refactored into a separate function for better readability.

### Day 5: [aoc2024-day5.py](aoc2024-day5.py)

**Score**: 7/10

**Strengths**:
- Clear separation of concerns with separate functions for parsing input, checking validity, fixing updates, and solving each part of the problem.
- Effective use of Python data structures like defaultdict and sets for representing rules.
- Good use of helper functions like rule_sets_, parse_input, is_valid_update, fix_one_update, and fixed_update_.
- Well-structured and readable code with meaningful variable names and comments.

**Weaknesses**:
- The fix_one_update and fixed_update_ functions could be optimized for better performance, especially for larger inputs.
- The solution assumes that the input is well-formed and does not handle invalid inputs or edge cases.
- The code could benefit from additional comments explaining the logic behind some of the functions.

**Issues**:
- In fix_one_update: The nested loops could potentially lead to inefficient performance for large inputs.
- In fixed_update_: The while loop could potentially run indefinitely if the update cannot be fixed, leading to an infinite loop.

### Day 6: [aoc2024-day6.py](aoc2024-day6.py)

**Score**: 8/10

**Strengths**:
- Well-structured and modular code with separate functions for parsing input, solving each part, and helper functions.
- Effective use of Python data structures (sets, frozensets, deque) and built-in functions.
- Good use of caching (lru_cache) to optimize the escaped_ function.
- Clear and concise variable names and comments explaining the purpose of functions.
- Efficient implementation of the guard's movement simulation and loop detection.

**Weaknesses**:
- The escaped_ function uses recursion, which could potentially lead to stack overflow for very large maps.
- The part2() function could be optimized further by avoiding redundant simulations for positions that are symmetrical or equivalent.
- The code lacks error handling for invalid or malformed input maps.
- The solution does not include any test cases or examples to verify correctness.

**Issues**:
- In escaped_: The recursive approach could be inefficient for very large maps.
- In part2: The breadth-first search could be memory-intensive for large maps with many potential obstruction positions.

### Day 7: [aoc2024-day7.py](aoc2024-day7.py)

**Score**: 7/10

**Strengths**:
- Clear separation of concerns with separate functions for parsing input, checking validity, and solving each part of the problem.
- Effective use of recursion to check all possible combinations of operators.
- Good use of helper functions like operate and equation_.
- Well-structured and readable code with meaningful variable names and comments.

**Weaknesses**:
- The recursive approach in is_valid_step could potentially lead to stack overflow for very large inputs.
- The solution does not handle invalid input gracefully (e.g. missing or non-numeric values).
- The code does not include any test cases or examples to verify correctness.

**Issues**:
- In is_valid_step: The recursive approach could be inefficient for very large inputs with many numbers and operators.
- In parse_input: The function does not handle invalid input lines or empty input.

### Day 8: [aoc2024-day8.py](aoc2024-day8.py)

**Score**: 7/10

**Strengths**:
- Modular design with separate functions for different tasks
- Efficient use of numpy arrays for grid representation and calculations
- Clever use of sets and dictionaries for tracking unique values and positions
- Handles both Part 1 and Part 2 with a single solve() function
- Includes test input and expected output for verification

**Weaknesses**:
- Lack of comments explaining the overall approach and key steps
- Verbose printing statements (controlled by VERBOSE flag) could clutter the output
- Hardcoded MARK value (9) for marking antinodes on the grid
- Potential performance issues for larger grids or more antennas

**Issues**:
- The antinodes_() function could be optimized for better performance, especially for larger grids
- The solution assumes valid input and does not handle edge cases or error conditions

### Day 9: [aoc2024-day9.py](aoc2024-day9.py)

**Score**: 7/10

**Strengths**:
- Well-structured code with separate functions for different tasks.
- Good use of helper functions and custom data structures (e.g. `cluster_`, `run_`).
- Efficient implementation of the file compaction process.
- Inclusion of debug and verbose modes for easier debugging and progress tracking.
- Clear separation of Part 1 and Part 2 solutions.
- Timing information provided for performance analysis.

**Weaknesses**:
- Lack of comments and docstrings for some functions and classes.
- Potential for performance issues with large inputs due to the use of lists and copying.
- Limited error handling and input validation.
- Some code duplication in the handling of runs and clusters.

**Issues**:
- The `run_list_` function could be optimized for better performance.
- The `RunEncoding` class could benefit from better memory management and more efficient data structures.
- The `defragment_run` method in `RunEncoding` could be optimized for better performance.

### Day 10: [aoc2024-day10.py](aoc2024-day10.py)

**Score**: 7/10

**Strengths**:
- Clear separation of concerns with separate functions for different tasks.
- Effective use of recursion to explore all possible paths.
- Good use of helper functions and modular code structure.
- Efficient use of Python data structures (sets and tuples) to store and process paths.
- Well-structured and readable code with meaningful variable names.

**Weaknesses**:
- Lack of error handling for invalid input maps.
- Potential performance issues for very large maps due to recursive approach.
- Limited comments explaining the logic behind the recursive functions.
- No optimization techniques or heuristics to improve search efficiency.

**Issues**:
- In `trailhead_destinations` and `complete_trails`: Recursive approach may lead to stack overflow for very large maps.
- In `part1` and `part2`: No error handling for maps without trailheads or invalid map dimensions.

### Day 11: [aoc2024-day11.py](aoc2024-day11.py)

**Score**: 8/10

**Strengths**:
- Clear separation of concerns with separate functions for different tasks.
- Effective use of dictionaries to store and update counts of unique numbers.
- Good use of helper functions (apply_rule(), blink_once(), blink_once_cache()).
- Well-structured and readable code with meaningful variable names.
- Inclusion of timing information for performance analysis.
- Efficient solution for Part 2 using a caching approach.

**Weaknesses**:
- Lack of comments explaining the purpose and logic of some functions (e.g. blink_once_cache()).
- No error handling or input validation for the initial list of numbers.
- Potential performance issues for Part 1 with very large inputs due to the iterative approach.

**Issues**:
- In blink_once_cache: The use of nested loops and dictionary lookups could potentially be optimized for better performance.
- In part2: The creation of a new dictionary (new_number_counts) for each blink could lead to memory overhead for very large inputs.

### Day 12: [aoc2024-day12.py](aoc2024-day12.py)

**Score**: 8/10

**Strengths**:
- Well-structured and modular code with separate functions for different tasks.
- Effective use of NumPy for efficient array operations and image processing.
- Clever use of bit manipulation to track edge conditions.
- Visualization of intermediate steps for debugging and understanding.
- Handling of edge cases and padding to simplify edge condition checks.
- Separation of concerns between image processing and problem-specific logic.

**Weaknesses**:
- Lack of docstrings and comments for some functions, making it harder to understand their purpose and implementation details.
- Potential performance issues for very large inputs due to the use of nested loops and recursion.
- Some code duplication in the handling of vertical and horizontal edges.
- Hardcoded constants (e.g. T, U, V) that could be made more configurable or explained better.
- Verbose output and image generation, which may not be necessary for the final solution.

**Issues**:
- In num_sides_(): The nested loops and recursive approach could lead to performance issues for very large inputs.
- In edge_counts_(): The nested loop could be optimized for better performance.
- In compose_img(): The nested loops and hardcoded constants could be improved for better readability and maintainability.

### Day 13: [aoc2024-day13.py](aoc2024-day13.py)

**Score**: 7/10

**Strengths**:
- Well-structured and modular code with separate functions for parsing input, solving equations, and handling parts 1 and 2.
- Effective use of regular expressions for parsing input data.
- Utilization of NumPy and SymPy libraries for efficient numerical and symbolic computations.
- Clear separation of concerns with helper functions like xy_(), parse_machine(), parse_input(), fractional(), and is_int().
- Inclusion of test cases (test_solve()) for verifying the correctness of the solve() function.
- Timing information provided for performance analysis.

**Weaknesses**:
- Lack of error handling for invalid input or edge cases.
- Limited comments and docstrings explaining the purpose and functionality of some functions.
- Potential performance issues for large inputs due to the use of symbolic computation (SymPy).
- The solve() function could be optimized further for specific cases where a closed-form solution exists.

**Issues**:
- In solve(): The use of SymPy's solve_linear_system could be inefficient for large systems of equations.
- In part1() and part2(): The printing of solution details could be separated into a dedicated function for better code organization.

### Day 14: [aoc2024-day14.py](aoc2024-day14.py)

**Score**: 7/10

**Strengths**:
- Well-structured code with separate functions for different tasks.
- Good use of regular expressions and helper functions.
- Efficient simulation of robot motion using modular arithmetic.
- Visualization of robot positions using matplotlib.
- Inclusion of test cases and example inputs.

**Weaknesses**:
- Lack of comments explaining the logic and purpose of some functions.
- Potential performance issues for large inputs or long simulations.
- Limited error handling and input validation.
- Hardcoded constants for tree detection criteria.

**Issues**:
- The is_tree() function could be optimized for better performance.
- The draw_img() function may encounter issues with large inputs or limited memory.
- The part2() function may not terminate for certain inputs due to the lack of a cycle detection mechanism.

### Day 15: [aoc2024-day15.py](aoc2024-day15.py)

**Score**: 7/10

**Strengths**:
- Well-structured and modular code with separate functions for different tasks.
- Effective use of NumPy arrays to represent the warehouse grid.
- Good use of helper functions and classes to encapsulate different aspects of the problem.
- Handling of both Part 1 and Part 2 scenarios within the same codebase.
- Inclusion of test cases and sample data for verification.
- Clear separation of concerns between parsing, simulation, and calculation of results.

**Weaknesses**:
- Lack of comments and docstrings to explain the purpose and functionality of some functions and classes.
- Potential performance issues for very large warehouse grids or long move sequences.
- Limited error handling and input validation.
- Some code duplication in the handling of different box types (single, left, right).
- The `move_box_pairs` method could be further optimized or refactored for better readability.

**Issues**:
- In the `move_box_pairs` method, the handling of box pairs and the frontier extension could be optimized for better performance.
- In the `advanced_boxes_` method, the use of a fixed loop limit (100) could potentially lead to issues for very large or complex warehouse layouts.
- In the `parse_input` function, the parsing of the input file could be more robust and handle different input formats.

### Day 16: [aoc2024-day16.py](aoc2024-day16.py)

**Score**: 9/10

**Strengths**:
- Well-organized structure with separate functions for different parts of the solution.
- Good use of comments to explain the purpose of functions and key parts of the code.
- Efficient use of A* search algorithm for pathfinding.
- Clever use of a heuristic function to optimize the search.
- Handling of multiple optimal paths, not just finding a single solution.
- Use of heapq for efficient priority queue implementation.
- Clear separation of Part 1 and Part 2 solutions.
- Inclusion of timing information for performance analysis.

**Weaknesses**:
- The solve_maze function is quite long and could potentially be split into smaller, more focused functions.
- Some magic numbers are used (e.g. PENALTY_MOVE = 1, PENALTY_TURN = 1000) which could be defined as constants at the top of the file for better maintainability.
- The reconstruct_paths function uses recursion, which could potentially lead to stack overflow for very large mazes.
- The solution doesn't handle invalid input gracefully (e.g. missing start or end points).
- There's some code duplication in the handling of predecessors and visited states.

**Issues**:
- In solve_maze: The handling of multiple paths and predecessors could potentially be memory-intensive for very large mazes.
- In reconstruct_paths: The recursive approach could be inefficient for very long paths.
- In part2: Creating a set of all tiles in all best paths could be memory-intensive for large mazes with many optimal paths.

### Day 17: [aoc2024-day17.py](aoc2024-day17.py)

**Score**: 7/10

**Strengths**:
- Well-structured and modular code with separate functions for different tasks.
- Effective use of regular expressions for parsing input.
- Good use of helper functions and functional programming techniques (e.g. `partial`).
- Inclusion of test cases and a testing mechanism.
- Clear separation of Part 1 and Part 2 solutions.
- Handling of edge cases and potential infinite loops.

**Weaknesses**:
- Lack of comments and docstrings explaining the purpose and functionality of some functions.
- Potential performance issues for large programs or input sizes due to the recursive nature of the `dfs` function.
- Limited error handling and input validation.

**Issues**:
- In `dfs`: The recursive approach could lead to stack overflow for very large programs or input sizes.
- In `execute_program`: The loop termination condition (`iterations > 1000`) is hardcoded and may not be suitable for all inputs.

### Day 18: [aoc2024-day18.py](aoc2024-day18.py)

**Score**: 8/10

**Strengths**:
- Well-structured code with separate functions for different tasks
- Efficient implementation of the Uniform Cost Search algorithm using a priority queue
- Effective use of Python data structures (lists, sets) and built-in functions
- Clear separation of concerns between the main problem-solving logic and helper functions
- Inclusion of test cases and examples for verifying the correctness of the solution

**Weaknesses**:
- Lack of comments and docstrings explaining the purpose and functionality of some functions
- Potential performance issues for larger grids or more byte positions due to the recursive path reconstruction
- Limited error handling and input validation

**Issues**:
- In `reconstruct_path`: The recursive approach could lead to stack overflow for very long paths.
- In `solve_grid`: The path reconstruction process could be inefficient for large grids or long paths.

### Day 19: [aoc2024-day19.py](aoc2024-day19.py)

**Score**: 7/10

**Strengths**:
- Clear separation of concerns with separate functions for different tasks.
- Effective use of memoization (`lru_cache`) to optimize the recursive DFS solution.
- Good use of helper functions (`lines_to_towels_and_designs`, `Q`) for input parsing and formatting.
- Inclusion of test cases (`test1`) to verify the correctness of the solution.
- Well-structured and readable code with meaningful variable names and comments.

**Weaknesses**:
- The `num_valid_designs` function could be further optimized for larger inputs by using more efficient data structures or algorithms.
- The solution does not handle invalid inputs or edge cases (e.g. empty patterns or designs).
- The use of global variables (`global_towels`) could be avoided by passing the towel patterns as an argument to the recursive function.
- The solution does not provide any performance analysis or benchmarking for larger inputs.

**Issues**:
- In `num_valid_designs`: The recursive DFS approach could potentially lead to stack overflow for very large inputs.
- In `part1` and `part2`: The solution does not handle empty or invalid inputs gracefully.

### Day 20: [aoc2024-day20.py](aoc2024-day20.py)

**Score**: 8/10

**Strengths**:
- Well-structured code with separate functions for different tasks.
- Efficient implementation of Uniform Cost Search for finding the shortest path.
- Clever use of dictionaries and sets for tracking visited states and reconstructing paths.
- Effective use of heapq for priority queue implementation.
- Separate functions for identifying improvements (cheats) for Part 1 and Part 2.
- Inclusion of test cases and example maze for verification.
- Clear separation of Part 1 and Part 2 solutions.

**Weaknesses**:
- Limited comments and docstrings, making it harder to understand the code at a glance.
- Some functions (e.g. improvements1_() and improvements2_()) could be further optimized for performance.
- No error handling or input validation for the maze data.
- The code assumes the presence of a start and end position in the maze.

**Issues**:
- In improvements1_(): The nested loops could potentially be optimized for better performance.
- In improvements2_(): The cheat_len_() function could be simplified or inlined for better readability.
- In part1() and part2(): The printing of results could be improved for better formatting and clarity.

### Day 21: [aoc2024-day21.py](aoc2024-day21.py)

**Score**: 8/10

**Strengths**:
- Well-structured and modular code with separate functions for different tasks.
- Effective use of recursion and memoization (caching) to optimize the solution.
- Good use of helper functions and data structures (e.g. Coord class, dictionaries).
- Clear separation of concerns (e.g. separate functions for numeric and directional keypads).
- Handles both parts of the problem with minimal code changes.
- Includes timing information for performance analysis.

**Weaknesses**:
- Lack of comments and docstrings to explain the purpose and functionality of functions.
- Some function names could be more descriptive (e.g. `num_presses_after_robot`).
- No error handling or input validation for edge cases or invalid inputs.
- The recursive approach could potentially lead to stack overflow for extremely large inputs.

**Issues**:
- In `num_presses_after_robot`: The recursive approach could be inefficient for extremely large inputs due to potential stack overflow.
- In `numeric_presses_` and `direction_presses_`: The code could be more concise and readable by using helper functions or list comprehensions.

### Day 22: [aoc2024-day22.py](aoc2024-day22.py)

**Score**: 7/10

**Strengths**:
- Well-structured code with separate functions for different tasks.
- Effective use of classes (BananaPrice and Sequence) to encapsulate data.
- Good use of helper functions (number_, mix_prune, secret_number_).
- Clear separation of Part 1 and Part 2 solutions.
- Inclusion of timing information for performance analysis.

**Weaknesses**:
- Lack of comments explaining the logic behind the mixing and pruning operations.
- The max_num_bananas_ function could be optimized for better performance.
- The run_monkey_market function could be refactored for better readability.
- No error handling or input validation for the input lines.

**Issues**:
- In max_num_bananas_: The nested loops and dictionary lookups could be inefficient for larger inputs.
- In run_monkey_market: The use of mutable default arguments ([] for lines) could lead to unexpected behavior.

### Day 23: [aoc2024-day23.py](aoc2024-day23.py)

**Score**: 8/10

**Strengths**:
- Well-structured and modular code with separate functions for different tasks.
- Effective use of Python data structures (defaultdict, sets) and built-in functions (sorted, join).
- Good use of helper functions and functional programming techniques (e.g. graph_, triplets_, num_t_triplets_).
- Implementation of the Bron-Kerbosch algorithm for finding maximal cliques.
- Inclusion of timing information for performance analysis.

**Weaknesses**:
- Lack of comments and docstrings to explain the purpose and functionality of some functions.
- Potential inefficiency for large inputs due to the nested loops in triplets_().
- No error handling or input validation for the network map format.

**Issues**:
- In triplets_: The nested loops could lead to inefficient performance for large inputs.
- In bron_kerbosch: The recursive implementation could potentially lead to stack overflow for very large graphs.


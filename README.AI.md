# Advent of Code 2024 Solutions

This repository contains Python solutions for the Advent of Code 2024 challenges.
           Below is a brief description of each day's problem and solution.

This docuement generated by the [readme.py](summarisers/readme.py) script.
        f"16 Python solutions were analysed.

### Day 1: Comparing Lists ([aoc2024-day1.py](aoc2024-day1.py))
- **Problem 2**: Calculate a total similarity score by adding up each number in the left list after multiplying it by the number of times that number appears in the right list.
- **Problem 1**: Calculate the sum of absolute differences between corresponding elements in two lists.
- **Solution 1**: Transposes the input lists to get columns, sorts each column, calculates the absolute difference between corresponding elements, and sums the differences.
- **Solution 2**: Transposes the input lists, counts the occurrences of each number in the right list, multiplies each number in the left list by its count in the right list, and sums the products.

### Day 2: Reactor Safety Report Validation ([aoc2024-day2.py](aoc2024-day2.py))
- **Problem 2**: If removing a single level from an invalid report would make it valid, consider the report valid. Count the number of valid reports under this relaxed condition.
- **Problem 1**: Determine if a report's levels are either all increasing or all decreasing, with adjacent levels differing by at most 3. Count the number of valid reports.
- **Solution 1**: Calculates the differences between adjacent levels, checks if all differences are positive (increasing) or negative (decreasing), and that the absolute differences are between 1 and 3. Counts the number of valid reports.
- **Solution 2**: Checks if the original report is valid using the Part 1 solution. If not, it iterates through the report, removing one level at a time and checking if the remaining report is valid. Counts the number of valid reports under this relaxed condition.

### Day 3: Corrupted Memory Processing ([aoc2024-day3.py](aoc2024-day3.py))
- **Problem 2**: Introduce new instructions do() and don't() that enable or disable future mul instructions. Only the most recent do() or don't() instruction applies. At the beginning, mul instructions are enabled. Calculate the sum of products for enabled mul instructions only.
- **Problem 1**: Identify valid multiplication instructions (mul(a,b)) in a given text and calculate the sum of their products.
- **Solution 1**: Uses a regular expression to find patterns of the form mul(a,b), extracts the numbers a and b, multiplies them, and sums the products.
- **Solution 2**: Uses another regular expression to find do() and don't() instructions. Splits the text into spans based on these instructions. Applies the Part 1 solution to each span where mul instructions are enabled, and sums the results.

### Day 4: Word Search Puzzles ([aoc2024-day4.py](aoc2024-day4.py))
- **Problem 2**: Find the number of 'X' shapes formed by 'MAS' words in the word search grid, where each 'MAS' can be read forwards or backwards.
- **Problem 1**: Find the number of occurrences of the word 'XMAS' in a given word search grid.
- **Solution 1**: Iterates through all 'X' positions, checks for 'M', 'A', 'S' in the 8 surrounding directions, and counts valid 'XMAS' occurrences.
- **Solution 2**: Iterates through all 'A' positions, checks for 'M' and 'S' in the two diagonal directions forming an 'X', and counts valid 'X' shapes.

### Day 5: Page Ordering Rules ([aoc2024-day5.py](aoc2024-day5.py))
- **Problem 2**: For the updates that are not valid according to the ordering rules, reorder the page numbers to make them valid, and find the middle page number of each reordered update.
- **Problem 1**: Given a set of page ordering rules and a list of updates (each containing a sequence of page numbers), identify the valid updates where the page numbers are ordered correctly according to the rules. For each valid update, find the middle page number.
- **Solution 1**: The code parses the input into a set of rules and a list of updates. It defines a function is_valid_update() that checks if an update follows the ordering rules. It then filters the list of updates to only include valid ones, finds the middle page number for each valid update, and sums those middle page numbers.
- **Solution 2**: The code defines a function validate_update() that takes an invalid update and reorders the page numbers to make it valid according to the rules. It then finds the reordered updates, calculates the middle page number for each, and sums those middle page numbers.

### Day 6: Guard Gallivant ([aoc2024-day6.py](aoc2024-day6.py))
- **Problem 2**: Find all possible positions where a single new obstruction can be placed to cause the guard to get stuck in a loop, avoiding the guard's starting position.
- **Problem 1**: Predict the path of a guard following a strict patrol protocol on a map with obstacles, and determine how many distinct positions the guard will visit before leaving the mapped area.
- **Solution 1**: Parses the input map, simulates the guard's movement following the protocol, and counts the number of distinct positions visited before the guard leaves the mapped area.
- **Solution 2**: Performs a breadth-first search from the guard's starting position, trying all possible obstruction placements and checking if the guard gets stuck in a loop using a recursive function. Counts the number of positions where an obstruction would cause a loop.

### Day 7: Equation Evaluation ([aoc2024-day7.py](aoc2024-day7.py))
- **Problem 2**: Same as Part 1, but with an additional operator '|' that concatenates two numbers.
- **Problem 1**: Given a set of equations with a target value and a sequence of numbers, determine which equations can be made true by inserting the + and * operators between the numbers to produce the target value when evaluated left-to-right.
- **Solution 1**: The code parses the input equations, defines a recursive function to check all possible operator insertions, and returns the equations that evaluate to the target value using only + and * operators.
- **Solution 2**: Similar to Part 1, but the recursive function also considers the '|' operator for concatenating numbers.

### Day 8: Antenna Antinodes ([aoc2024-day8.py](aoc2024-day8.py))
- **Problem 2**: Antinodes now occur at any grid position exactly in line with at least two antennas of the same frequency, regardless of distance.
- **Problem 1**: Identify the grid positions that are antinodes, which occur at points perfectly in line with two antennas of the same frequency, where one antenna is twice as far away as the other.
- **Solution 1**: Iterates over pairs of antenna positions, calculates the line between them, and marks grid positions along that line as antinodes, excluding positions that are also in line with antennas of different frequencies.
- **Solution 2**: Similar to Part 1, but marks all grid positions along the line between any pair of antennas with the same frequency as antinodes, without the distance constraint.

### Day 9: Disk File Compaction ([aoc2024-day9.py](aoc2024-day9.py))
- **Problem 2**: Compact the disk map by moving whole files to the leftmost span of free space that can fit them, in decreasing order of file ID. Calculate the checksum as in Part 1.
- **Problem 1**: Compact a disk map by moving file blocks one at a time to the leftmost free space, until there are no gaps between file blocks. Calculate the checksum by multiplying each block's position by its file ID and summing the results.
- **Solution 1**: Iterates through the blocks from both ends, moving non-free blocks to the left and free blocks to the right. Calculates the checksum by summing the product of position and file ID for non-free blocks.
- **Solution 2**: Represents the disk map as a list of runs (clusters of file blocks and gaps). Iterates through runs in reverse order, moving clusters to the leftmost run with enough free space. Calculates the checksum from the compacted run list.

### Day 10: Hiking Trail Scoring ([aoc2024-day10.py](aoc2024-day10.py))
- **Problem 2**: Calculate the rating of each trailhead, which is the number of distinct hiking trails that begin at that trailhead. A hiking trail is a sequence of positions with increasing heights from 0 to 9.
- **Problem 1**: Given a topographic map represented as a grid of heights from 0 to 9, calculate the sum of scores for all trailheads (positions with height 0). A trailhead's score is the number of positions with height 9 that can be reached from that trailhead via a hiking trail (by moving to adjacent positions with increasing height).
- **Solution 1**: Implements a recursive function trailhead_destinations that calculates the set of positions with height 9 reachable from a given starting position by following increasing heights. Iterates over all positions with height 0, calls trailhead_destinations, and sums the lengths of the resulting sets.
- **Solution 2**: Implements a recursive function complete_trails that calculates the set of complete hiking trails (sequences of positions with heights 0 to 9) that can be reached from a given starting position. Iterates over all positions with height 0, calls complete_trails, and sums the lengths of the resulting sets of trails.

### Day 11: Blinking Stones ([aoc2024-day11.py](aoc2024-day11.py))
- **Problem 2**: Same as Part 1, but count the total number of stones after 75 blinks.
- **Problem 1**: Given a list of numbers engraved on stones, apply a set of rules to transform the numbers after blinking 25 times. The rules involve replacing numbers with new numbers based on certain conditions. Count the total number of stones after 25 blinks.
- **Solution 1**: Iterates over the list of numbers 25 times, applying the rules to each number using the apply_rule() function and creating a new list with the transformed numbers using blink_once().
- **Solution 2**: Uses a cache to store the results of applying the rules to each number. Maintains a dictionary of {number: count} to keep track of the number of occurrences of each number. Applies the rules using blink_once_cache() which updates the dictionary based on the cached results. Sums the counts in the final dictionary to get the total number of stones.

### Day 12: Garden Plot Fencing ([aoc2024-day12.py](aoc2024-day12.py))
- **Problem 2**: Instead of using the perimeter to calculate the fencing cost, use the number of straight sections (sides) required to fence each region, regardless of their length.
- **Problem 1**: Given a map of garden plots where each plot grows a single type of plant, calculate the total cost of fencing all regions of connected plots of the same plant type. The cost is the area of a region multiplied by its perimeter.
- **Solution 1**: The code identifies connected components of the same plant type, calculates the area and perimeter of each region, and sums the products of area and perimeter across all regions.
- **Solution 2**: The code identifies the sides of each connected component that are not shared with another component, counts the number of such sides for each component, and sums the products of area and number of sides across all components.

### Day 13: Claw Machine Prize Positioning ([aoc2024-day13.py](aoc2024-day13.py))
- **Problem 2**: The prize locations were incorrectly measured, and are actually 10000000000000 higher on both X and Y axes. Find the minimum number of tokens required to win all possible prizes with the corrected locations.
- **Problem 1**: Given the button presses and prize locations for multiple claw machines, find the minimum number of tokens required to win all possible prizes.
- **Solution 1**: Parses the input data, solves the linear equations for each machine to find the required button presses, and sums the costs for all machines where a solution exists.
- **Solution 2**: Adds 10000000000000 to the X and Y coordinates of each prize location, then uses the same approach as Part 1 to solve the linear equations and sum the costs for machines with solutions.

### Day 14: Restroom Redoubt ([aoc2024-day14.py](aoc2024-day14.py))
- **Problem 2**: Find the fewest number of seconds for the robots to arrange themselves into a picture of a Christmas tree, which is a hard-coded Easter egg.
- **Problem 1**: Predict the motion of robots in a 101x103 tile space after 100 seconds have elapsed, and calculate the safety factor by multiplying the number of robots in each quadrant.
- **Solution 1**: Parses the input to get robot positions and velocities. Simulates the robot motion for 100 seconds, wrapping around edges. Counts the number of robots in each quadrant and multiplies them together to get the safety factor.
- **Solution 2**: Simulates the robot motion, checking at each step if the robots form a Christmas tree pattern. A tree pattern is defined as having few robots in the corners and a contiguous 3x3 block of robots. Outputs the first time step where a tree pattern is found.

### Day 15: Warehouse Robot Movement Simulation ([aoc2024-day15.py](aoc2024-day15.py))
- **Problem 2**: Simulate the movement of the robot in a scaled-up warehouse where boxes are twice as wide. Calculate the sum of GPS coordinates of all boxes after the robot finishes moving in this scaled-up warehouse.
- **Problem 1**: Simulate the movement of a robot in a warehouse with boxes, following a given sequence of moves. Calculate the sum of GPS coordinates of all boxes after the robot finishes moving.
- **Solution 1**: Represents the warehouse as a 2D numpy array, with values for walls, spaces, boxes, and the robot. Implements functions to parse the input, move the robot and boxes according to the rules, and calculate the sum of box coordinates.
- **Solution 2**: Extends the Part 1 solution to handle wide boxes represented by pairs of values in the grid. Implements functions to validate the scaled-up grid, move wide boxes according to the rules, and calculate the sum of box coordinates in the scaled-up warehouse.

### Day 16: Reindeer Maze ([aoc2024-day16.py](aoc2024-day16.py))
- **Problem 2**: Determine how many tiles are part of at least one of the best paths through the maze, including the start and end tiles.
- **Problem 1**: Find the lowest score a Reindeer could get while navigating a maze from the start tile to the end tile. The Reindeer can move forward one tile at a time or rotate 90 degrees clockwise or counterclockwise, incurring penalties for each move.
- **Solution 1**: Uses A* search algorithm to find the least costly path(s) through the maze. Maintains a priority queue of states (turns, direction, position, cost) and explores neighbors, updating costs and tracking predecessors to reconstruct paths. Returns the minimum cost path(s).
- **Solution 2**: Reuses the A* search from Part 1 to find all optimal paths. Collects the set of tiles that are part of any optimal path and reports the count.


# Advent of Code 2024 Solutions

This repository contains Python solutions for the Advent of Code 2024 challenges.
           Below is a brief description of each day's problem and solution.

This docuement generated by the [readme.py](summarisers/readme.py) script.
        f"23 Python solutions were analysed.

### Day 1: Comparing Lists ([aoc2024-day1.py](aoc2024-day1.py))
- **Problem 1**: Calculate the sum of absolute differences between corresponding elements in two lists.
- **Problem 2**: Calculate a total similarity score by adding up each number in the left list after multiplying it by the number of times that number appears in the right list.
- **Solution 1**: Reads input lines as pairs of numbers, transposes the pairs into two columns, calculates the absolute difference between corresponding elements in the columns, and sums the differences.
- **Solution 2**: Reads input lines as pairs of numbers, transposes the pairs into two columns, counts the occurrences of each number in the right column, multiplies each number in the left column by its count in the right column, and sums the products.

### Day 2: Reactor Safety Report Validation ([aoc2024-day2.py](aoc2024-day2.py))
- **Problem 1**: Determine if a report's levels are either all increasing or all decreasing, with adjacent levels differing by at most 3. Count the number of valid reports.
- **Problem 2**: If removing a single level from an invalid report would make it valid, count that report as valid. Count the number of valid reports with this relaxed rule.
- **Solution 1**: Calculates the differences between adjacent levels, checks if all differences are positive (increasing) or negative (decreasing), and that the absolute differences are between 1 and 3.
- **Solution 2**: Iterates through each level in an invalid report, removes it, and checks if the remaining report is valid using the Part 1 solution. If any removal results in a valid report, it is counted as valid.

### Day 3: Corrupted Memory Processing ([aoc2024-day3.py](aoc2024-day3.py))
- **Problem 1**: Identify valid multiplication instructions (mul(a,b)) in a given text and calculate the sum of their products.
- **Problem 2**: Introduce new instructions do() and don't() that enable or disable future mul instructions. Only the most recent do() or don't() instruction applies. At the beginning, mul instructions are enabled. Calculate the sum of products for enabled mul instructions only.
- **Solution 1**: Uses a regular expression to find patterns of the form mul(a,b), extracts the numbers a and b, multiplies them, and sums the products.
- **Solution 2**: Uses another regular expression to find do() and don't() instructions. Splits the text into spans based on these instructions. Applies the Part 1 solution to each span where mul instructions are enabled, and sums the results.

### Day 4: Word Search Puzzles ([aoc2024-day4.py](aoc2024-day4.py))
- **Problem 1**: Find the number of occurrences of the word 'XMAS' in a given word search grid.
- **Problem 2**: Find the number of 'X' shapes formed by 'MAS' words in the word search grid, where each 'MAS' can be read forwards or backwards.
- **Solution 1**: Iterates through all 'X' positions, checks for 'M', 'A', 'S' in the 8 surrounding directions, and counts valid 'XMAS' occurrences.
- **Solution 2**: Iterates through all 'A' positions, checks for 'M' and 'S' in the two diagonal directions forming an 'X', and counts valid 'X' shapes.

### Day 5: Page Ordering Rules ([aoc2024-day5.py](aoc2024-day5.py))
- **Problem 1**: Given a set of page ordering rules and a list of updates (each containing a sequence of page numbers), find the correctly ordered updates and calculate the sum of the middle page numbers.
- **Problem 2**: For the incorrectly ordered updates, reorder the page numbers according to the rules and find the sum of the middle page numbers in the reordered updates.
- **Solution 1**: Parses the input into rules and updates. Checks if each update obeys the rules by iterating through the pages and checking if any preceding page should come after the current page according to the rules. Finds the valid updates, extracts the middle page number from each, and sums them.
- **Solution 2**: Identifies the invalid updates, reorders each one by swapping pages that violate the rules until the update is valid, extracts the middle page number from each reordered update, and sums them.

### Day 6: Guard Gallivant ([aoc2024-day6.py](aoc2024-day6.py))
- **Problem 1**: Predict the path of a guard following a strict patrol protocol on a map with obstacles, and determine how many distinct positions the guard will visit before leaving the mapped area.
- **Problem 2**: Find all possible positions where a single new obstruction can be placed to cause the guard to get stuck in a loop, avoiding the guard's starting position.
- **Solution 1**: Parses the input map, simulates the guard's movement following the protocol, and counts the number of distinct positions visited before the guard leaves the mapped area.
- **Solution 2**: Performs a breadth-first search from the guard's starting position, trying all possible obstruction placements and checking if the guard gets stuck in a loop using a recursive function. Counts the number of positions where an obstruction would cause a loop.

### Day 7: Equation Evaluation ([aoc2024-day7.py](aoc2024-day7.py))
- **Problem 1**: Given a list of equations with a target value and a sequence of numbers, determine which equations can be made true by combining the numbers using addition and multiplication operators, evaluated left-to-right.
- **Problem 2**: Same as Part 1, but with an additional operator that concatenates numbers.
- **Solution 1**: Parses the input equations into target values and number sequences. Uses a recursive function to try all possible combinations of addition and multiplication operators on the number sequences, evaluating left-to-right. Returns the sum of target values for valid equations.
- **Solution 2**: Similar to Part 1, but adds the concatenation operator to the list of allowed operators in the recursive function.

### Day 8: Antenna Antinodes ([aoc2024-day8.py](aoc2024-day8.py))
- **Problem 1**: Identify the grid positions that are antinodes, which occur at points perfectly in line with two antennas of the same frequency, where one antenna is twice as far away as the other.
- **Problem 2**: Antinodes now occur at any grid position exactly in line with at least two antennas of the same frequency, regardless of distance.
- **Solution 1**: Iterates over pairs of antenna positions, calculates the line between them, and marks grid positions along that line as antinodes, excluding positions that are also in line with antennas of different frequencies.
- **Solution 2**: Similar to Part 1, but marks all grid positions along the line between any pair of antennas with the same frequency as antinodes, without the distance constraint.

### Day 9: Disk File Compaction ([aoc2024-day9.py](aoc2024-day9.py))
- **Problem 1**: Compact a disk map by moving file blocks one at a time from the end to the leftmost free space, until there are no gaps between file blocks. Calculate the checksum by multiplying each block's position by its file ID and summing the results.
- **Problem 2**: Compact the disk map by moving whole files to the leftmost span of free space that can fit them, in decreasing order of file ID. Calculate the checksum as in Part 1.
- **Solution 1**: Iterates through the disk map from both ends, moving non-free blocks to the left and free blocks to the right. Calculates the checksum by summing the product of each non-free block's position and its file ID.
- **Solution 2**: Represents the disk map as a list of runs (clusters of file blocks and gaps). Iterates through runs in reverse order, moving each cluster to the leftmost run with enough free space to fit it. Calculates the checksum from the compacted disk map.

### Day 10: Hiking Trail Scoring ([aoc2024-day10.py](aoc2024-day10.py))
- **Problem 1**: Given a topographic map with heights from 0 to 9, calculate the sum of scores for all trailheads (positions with height 0). A trailhead's score is the number of positions with height 9 reachable from that trailhead via a hiking trail.
- **Problem 2**: Calculate the sum of ratings for all trailheads, where a trailhead's rating is the number of distinct hiking trails of length 18 (9*2) that start at that trailhead and visit all heights from 0 to 9.
- **Solution 1**: Implements a recursive function trailhead_destinations() that explores all paths starting from a trailhead and counts the number of destinations with height 9.
- **Solution 2**: Implements a recursive function complete_trails() that explores all paths starting from a trailhead and counts the number of distinct trails of length 18 that visit all heights from 0 to 9.

### Day 11: Blinking Stones ([aoc2024-day11.py](aoc2024-day11.py))
- **Problem 1**: Given a list of numbers engraved on stones, apply a set of rules to transform the numbers after blinking 25 times. The rules involve replacing numbers with new numbers based on certain conditions. Count the total number of stones after 25 blinks.
- **Problem 2**: Same as Part 1, but count the total number of stones after 75 blinks.
- **Solution 1**: Iterates over the list of numbers 25 times, applying the rules to each number using the apply_rule() function and creating a new list with the transformed numbers using blink_once().
- **Solution 2**: Uses a cache to store the results of applying the rules to each number. Maintains a dictionary of {number: count} to keep track of the number of occurrences of each number. Applies the rules using blink_once_cache() which updates the dictionary based on the cached results. Sums the counts in the final dictionary to get the total number of stones.

### Day 12: Garden Plot Fencing ([aoc2024-day12.py](aoc2024-day12.py))
- **Problem 1**: Given a map of garden plots where each plot grows a single type of plant, calculate the total cost of fencing all regions of connected plots of the same plant type. The cost is the area of a region multiplied by its perimeter.
- **Problem 2**: Instead of using the perimeter to calculate the fencing cost, use the number of straight sections (sides) required to fence each region, regardless of length.
- **Solution 1**: The code identifies connected components of the same plant type, calculates the area and perimeter of each region, and sums the products of area and perimeter across all regions.
- **Solution 2**: The code identifies the sides of each connected component that are not shared with another component, counts the number of such sides for each component, and sums the products of area and number of sides across all components.

### Day 13: Claw Machine Prize Positioning ([aoc2024-day13.py](aoc2024-day13.py))
- **Problem 1**: Given the button presses and prize locations for multiple claw machines, find the minimum number of tokens required to win all possible prizes.
- **Problem 2**: The prize locations were incorrectly measured, and are actually 10000000000000 higher on both X and Y axes. Find the minimum number of tokens required to win all possible prizes with the corrected locations.
- **Solution 1**: Parses the input data, solves the linear equations for each machine to find the required button presses, and sums the costs for all machines where a solution exists.
- **Solution 2**: Adds 10000000000000 to the X and Y coordinates of each prize location, then uses the same approach as Part 1 to solve the linear equations and sum the costs for machines with solutions.

### Day 14: Restroom Redoubt ([aoc2024-day14.py](aoc2024-day14.py))
- **Problem 1**: Predict the motion of robots in a 101x103 tile space after 100 seconds have elapsed, and calculate the safety factor by multiplying the number of robots in each quadrant.
- **Problem 2**: Find the fewest number of seconds for the robots to arrange themselves into a picture of a Christmas tree, which is a hard-coded Easter egg.
- **Solution 1**: Parses the input to get robot positions and velocities. Simulates the robot motion for 100 seconds, wrapping around edges. Counts the number of robots in each quadrant and multiplies them together to get the safety factor.
- **Solution 2**: Simulates the robot motion, checking at each step if the robots form a Christmas tree pattern. A tree pattern is defined as having few robots in the corners and a contiguous 3x3 block of robots. Outputs the first time step where a tree pattern is found.

### Day 15: Warehouse Robot Movement Simulation ([aoc2024-day15.py](aoc2024-day15.py))
- **Problem 1**: Simulate the movement of a robot in a warehouse with boxes, following a given sequence of moves. Calculate the sum of GPS coordinates of all boxes after the robot finishes moving.
- **Problem 2**: Simulate the movement of the robot in a scaled-up warehouse where boxes are twice as wide. Calculate the sum of GPS coordinates of all boxes after the robot finishes moving in this scaled-up warehouse.
- **Solution 1**: Represents the warehouse as a 2D numpy array, with values for walls, spaces, boxes, and the robot. Implements functions to parse the input, move the robot and boxes according to the rules, and calculate the sum of box coordinates.
- **Solution 2**: Extends the Part 1 solution to handle wide boxes represented by pairs of values in the grid. Implements functions to validate the scaled-up grid, move wide boxes according to the rules, and calculate the sum of box coordinates in the scaled-up warehouse.

### Day 16: Reindeer Maze Navigation ([aoc2024-day16.py](aoc2024-day16.py))
- **Problem 1**: Find the lowest score a reindeer could get while navigating a maze from the start tile to the end tile, where moving forward costs 1 point and turning 90 degrees costs 1000 points.
- **Problem 2**: Determine how many tiles are part of at least one of the best paths through the maze.
- **Solution 1**: Uses Uniform Cost Search with a priority queue to find the least costly paths through the maze, keeping track of visited states and predecessors to reconstruct the paths.
- **Solution 2**: Reconstructs all the best paths found in Part 1 and counts the unique tiles that are part of any of those paths.

### Day 17: Chronospatial Computer ([aoc2024-day17.py](aoc2024-day17.py))
- **Problem 1**: Determine the output of a program running on a 3-bit computer with 8 instructions and 3 registers (A, B, C). The program is given as a list of 3-bit numbers representing opcodes and operands.
- **Problem 2**: Find the lowest positive initial value for register A that causes the program to output an exact copy of itself.
- **Solution 1**: Parses the input to extract the program and initial register values. Implements an execute_program function that simulates the 8 instructions using the given operands and register values. Outputs the result by joining the values produced by the OUT instruction.
- **Solution 2**: Implements a depth-first search (dfs) function that recursively searches for the value of register A that produces the given program as output. The search is guided by the observation that the output is the low 3 bits of register A shifted left by 3 bits and possibly XORed with constants or other registers.

### Day 18: RAM Run ([aoc2024-day18.py](aoc2024-day18.py))
- **Problem 1**: Simulate the first 1024 bytes falling onto a 71x71 memory space grid, where you start at (0,0) and need to reach the exit at (70,70). Corrupted coordinates cannot be entered. Find the minimum number of steps needed to reach the exit.
- **Problem 2**: Determine the coordinates of the first byte that will prevent the exit from being reachable from the starting position (0,0).
- **Solution 1**: Creates a 2D grid representing the memory space. Marks the positions of the falling bytes as walls. Uses Uniform Cost Search with a priority queue to find the shortest path from (0,0) to (70,70), avoiding walls. Returns the length of the shortest path.
- **Solution 2**: Builds the grid as in Part 1. Finds the initial shortest path to the exit. Then iterates through the remaining bytes, temporarily marking each one as a wall. If this makes the exit unreachable, that byte's coordinates are the answer. Returns the coordinates of the first such byte.

### Day 19: Towel Arrangement ([aoc2024-day19.py](aoc2024-day19.py))
- **Problem 1**: Given a list of available towel patterns (sequences of colored stripes) and a list of desired designs (sequences of colored stripes), determine how many of the desired designs can be created by combining the available towel patterns.
- **Problem 2**: For each desired design that can be constructed, count the number of different ways it can be constructed by combining the available towel patterns.
- **Solution 1**: Uses a depth-first search with memoization to check if each desired design can be constructed by concatenating available towel patterns. Counts the number of designs that can be constructed.
- **Solution 2**: Extends the depth-first search from Part 1 to also count the number of different ways each valid design can be constructed. Sums these counts across all valid designs.

### Day 20: Race Condition Festival ([aoc2024-day20.py](aoc2024-day20.py))
- **Problem 1**: Find the number of cheats that save at least 100 picoseconds in a race condition festival where programs can cheat for up to 2 picoseconds by passing through walls.
- **Problem 2**: Find the number of cheats that save at least 100 picoseconds in the updated rules where a single cheat lasting up to 20 picoseconds is allowed.
- **Solution 1**: Uses Uniform Cost Search to find the shortest path through the maze. Identifies potential cheats by finding wall cells adjacent to the path that could be skipped. Counts the number of cheats that save at least 100 picoseconds.
- **Solution 2**: Uses the same approach as Part 1, but identifies potential cheats as sequences of up to 20 cells that could be skipped. Counts the number of cheats that save at least 100 picoseconds.

### Day 21: Keypad Conundrum ([aoc2024-day21.py](aoc2024-day21.py))
- **Problem 1**: Find the fewest number of button presses needed to cause a robot to type five given codes on a numeric keypad, where the robot is controlled by a chain of directional keypads.
- **Problem 2**: Same as Part 1, but with a longer chain of 25 directional keypads controlling the robot typing on the numeric keypad.
- **Solution 1**: Implements functions to translate between numeric keypad presses, directional keypad presses, and the final directional keypad presses needed to control the robot. Caches intermediate results to improve performance. Calculates the complexity of each code as the product of the number of final directional keypad presses and the numeric part of the code.
- **Solution 2**: Uses the same approach as Part 1, but accounts for the longer chain of directional keypads.

### Day 22: Monkey Market ([aoc2024-day22.py](aoc2024-day22.py))
- **Problem 1**: Simulate the generation of 2000 secret numbers for each buyer on the Monkey Exchange Market, where each secret number is derived from the previous one through a series of operations (mixing and pruning). Calculate the sum of the 2000th secret number generated by each buyer.
- **Problem 2**: Find the sequence of four consecutive price changes (derived from the secret numbers) that will maximize the total number of bananas obtained by selling to each buyer when that sequence is observed. The monkey will sell to a buyer the first time it sees the given sequence of price changes.
- **Solution 1**: The code defines functions to calculate the next secret number in the sequence (secret_number_) and runs a simulation (run_monkey_market) to generate 2000 secret numbers for each input line (representing a buyer). The sum of the 2000th secret number for each buyer is calculated and printed.
- **Solution 2**: The code defines a function (max_num_bananas_) that analyzes the price changes for each buyer and finds the sequence of four changes that maximizes the total number of bananas obtained by selling at the first occurrence of that sequence for each buyer. The optimal sequence and the corresponding maximum number of bananas are printed.

### Day 23: LAN Party ([aoc2024-day23.py](aoc2024-day23.py))
- **Problem 1**: Find all sets of three inter-connected computers in a network, and count how many of those sets contain at least one computer whose name starts with 't'.
- **Problem 2**: Find the largest set of computers in the network where every computer is connected to every other computer in the set. The password to the LAN party is the sorted, comma-separated list of computer names in this largest set.
- **Solution 1**: Constructs an adjacency list representation of the network from the input data. Iterates through the adjacency list to find triplets of connected computers. Counts the number of triplets where at least one computer name starts with 't'.
- **Solution 2**: Implements the Bron-Kerbosch algorithm to find all maximal cliques (sets of fully connected nodes) in the network graph. Returns the largest such clique, which represents the LAN party, and prints the comma-separated list of computer names as the password.


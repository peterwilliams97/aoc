# Advent of Code 2024 Python Solutions Critique

This document provides a critique of the Python solutions for Advent of Code 2024.
            It was generated by the [critique.py](summarisers/critique.py) script.

25 Python solutions were analysed.

## Overall

_The solutions demonstrate a good understanding of Python programming and problem-solving skills. They effectively address the problems using appropriate data structures, algorithms, and techniques. While there are areas for improvement, such as optimizing for efficiency, improving readability, and handling edge cases, the overall quality of the solutions is good. With some refinements and attention to best practices, these solutions could be further improved._

**Overall Score**: 8/10

**Main Strength**:
1. Clear separation of concerns with modular code and separate functions for different tasks
1. Effective use of Python data structures like lists, dictionaries, sets, and tuples
1. Good use of functional programming techniques like list comprehensions and generator expressions
1. Appropriate use of algorithms like breadth-first search, depth-first search, and uniform cost search
1. Effective use of caching and memoization techniques for performance optimization
1. Well-structured and readable code with meaningful variable names and comments

**Main Weaknesses**:
1. Some solutions could be more efficient, especially for larger inputs or more complex cases
1. Lack of comments or docstrings explaining the logic and approach in some files
1. Potential issues with handling edge cases or invalid inputs
1. Opportunities for refactoring and simplifying code in some places
1. Overuse of global variables or hardcoded values in some solutions
1. Limited test cases or lack of input validation in some files

**Main Issues**:
1. Nested loops or recursive functions that could lead to performance issues for large inputs
1. Redundant computations or unnecessary iterations in some functions
1. Minor bugs or violations of problem constraints in a few solutions
1. Code duplication or lack of abstraction in some places
1. Verbose or complex code that could be simplified or refactored

**Areas for Improvement**:
1. Improving code efficiency and optimizing for better performance, especially for larger inputs
1. Writing more comments, docstrings, and explanations for complex logic or algorithms
1. Improving input validation and handling edge cases or invalid inputs
1. Refactoring and simplifying code for better readability and maintainability
1. Adhering to best practices like avoiding global variables and hardcoded values
1. Writing more comprehensive test cases to ensure correctness and robustness

## Files Analyzed

### Day 1: [aoc2024-day1.py](aoc2024-day1.py)

**Score**: 8/10

**Strengths**:
- Clear separation of concerns with separate functions for each part.
- Effective use of Python data structures and built-in functions (zip, sorted, abs).
- Good use of list comprehensions and functional programming techniques.

**Weaknesses**:
- Lack of comments explaining the logic or approach.
- Hardcoded test input file path.
- No error handling or input validation.

**Issues**:
- The part2 function creates a dictionary right_counts to store the counts of numbers in the right column, but this could be simplified using a Counter from the collections module.
- The part1 function sorts each column, but this is unnecessary since the problem only requires finding the absolute difference between adjacent elements.

### Day 2: [aoc2024-day2.py](aoc2024-day2.py)

**Score**: 7/10

**Strengths**:
- Clear separation of concerns with modular functions.
- Effective use of Python data structures and built-in functions (zip, list comprehensions).
- Good use of helper functions (diff_, pos_neg).

**Weaknesses**:
- The is_valid_ function could be simplified by checking the absolute differences instead of separating positive and negative differences.
- The is_valid_tol function could be optimized by stopping the loop early if a valid sequence is found.

**Issues**:
- The is_valid_ function has a minor issue: it treats sequences like [1, 2, 3, 4] as invalid because the differences are all positive but not between 1 and 3. This violates the problem description.
- The is_valid_tol function has a minor issue: it considers sequences like [1, 2, 3, 4, 5] as valid because removing any single number makes it valid. However, the problem description states that the sequence should be either increasing or decreasing, which this sequence is not.

### Day 3: [aoc2024-day3.py](aoc2024-day3.py)

**Score**: 8/10

**Strengths**:
- Clear separation of concerns with separate functions for finding mul expressions, calculating products, and solving each part.
- Effective use of regular expressions to parse the input string.
- Good use of helper functions like sum_total and spans_.
- Well-structured and readable code with meaningful variable names.

**Weaknesses**:
- The spans_ function could be more efficient by avoiding unnecessary iterations over the input string.
- The part2 function could be optimized by combining the finding of spans and calculation of products into a single pass.

**Issues**:
- The spans_ function iterates over the entire input string for each do/don't instruction, which could be inefficient for large inputs.
- The part2 function performs two separate passes over the input string, one for finding spans and another for calculating products within each span.

### Day 4: [aoc2024-day4.py](aoc2024-day4.py)

**Score**: 8/10

**Strengths**:
- Clear separation of concerns with separate functions for part 1 and part 2.
- Effective use of helper functions like char_positions to find positions of characters in the grid.
- Good use of list comprehensions and set operations to generate all possible spans.

**Weaknesses**:
- The spans list in part 1 could be generated more concisely using a nested list comprehension.
- The part 2 solution could be made more readable by breaking down the nested loop into separate helper functions.

**Issues**:
- In part 1, the spans list contains duplicate entries (e.g. (1, 0) and (-1, 0)) which could lead to unnecessary computations.
- The part 2 solution does not handle the case where there are multiple 'A' characters forming valid 'X' shapes, potentially leading to overcounting.

### Day 5: [aoc2024-day5.py](aoc2024-day5.py)

**Score**: 8/10

**Strengths**:
- Clear separation of concerns with separate functions for parsing input, checking validity, fixing updates, and solving each part of the problem.
- Effective use of Python data structures like sets and defaultdicts.
- Good use of helper functions and list comprehensions.

**Weaknesses**:
- The fix_one_update function could be more efficient by breaking out of the inner loop once a swap is made.
- The fixed_update_ function could be more efficient by keeping track of the changes made and only checking the affected pages on subsequent iterations.

**Issues**:
- The fix_one_update function has a nested loop that could be inefficient for large inputs.
- The fixed_update_ function repeatedly calls fix_one_update, which could be inefficient for large inputs.

### Day 6: [aoc2024-day6.py](aoc2024-day6.py)

**Score**: 8/10

**Strengths**:
- Clear separation of concerns with separate functions for parsing input, simulating guard movement, and solving each part of the problem.
- Effective use of Python data structures like sets and frozensets for representing obstacles and visited positions.
- Good use of helper functions like char_positions and lru_cache for performance optimization.

**Weaknesses**:
- The code could benefit from more comments explaining the logic and approach, especially for the part2 function.
- The use of global variables like DIRECTION_DYDX could be avoided by passing them as function arguments or using a class.

**Issues**:
- The escaped_ function is recursive and could potentially cause a stack overflow for large inputs, although the use of lru_cache helps mitigate this issue.
- The part2 function could be optimized further by avoiding redundant computations when checking for loops.

### Day 7: [aoc2024-day7.py](aoc2024-day7.py)

**Score**: 8/10

**Strengths**:
- Clear separation of concerns with modular functions.
- Effective use of recursion to explore all possibilities.
- Good use of helper functions like operate() and is_valid_step().

**Weaknesses**:
- The recursive is_valid_step() function could potentially lead to stack overflow for very large inputs.
- The code doesn't handle potential invalid inputs (e.g. empty lines, non-numeric values).

**Issues**:
- The is_valid_step() function could be optimized by short-circuiting when the current value exceeds the target result.
- The operate() function could be simplified by using a dictionary instead of multiple if statements.

### Day 8: [aoc2024-day8.py](aoc2024-day8.py)

**Score**: 7/10

**Strengths**:
- The code is well-structured and modular, with separate functions for different tasks.
- It uses numpy arrays effectively to represent and manipulate the grid.
- The use of sets and sorting helps in efficiently handling the antenna pairs and antinodes.

**Weaknesses**:
- The code could be more concise by using list comprehensions or generator expressions in some places.
- The verbose printing statements could be removed or made conditional for better readability.
- The code could benefit from more comments explaining the logic and approach.

**Issues**:
- The antinodes_ function has some nested loops and conditional statements that could potentially be optimized for better performance.
- The solve function has a lot of logic and could be split into smaller, more focused functions.
- The use of global variables like VERBOSE and MARK could be avoided by passing them as arguments or using a configuration object.

### Day 9: [aoc2024-day9.py](aoc2024-day9.py)

**Score**: 7/10

**Strengths**:
- Clear separation of concerns with modular functions and classes.
- Effective use of Python data structures and functional programming techniques.
- Well-structured and readable code with meaningful variable names and comments.

**Weaknesses**:
- The RunEncoding class could be simplified or refactored for better readability.
- The defragment_run function could be optimized for better efficiency.
- The code could benefit from more comments explaining the logic behind certain functions.

**Issues**:
- The insert_cluster function in the RunEncoding class has a potential off-by-one error in the gap calculation.
- The defragment_run function iterates through all previous runs for each cluster, which could be inefficient for large inputs.
- The code does not handle edge cases or invalid inputs, such as negative or non-digit characters in the input string.

### Day 10: [aoc2024-day10.py](aoc2024-day10.py)

**Score**: 7/10

**Strengths**:
- The code is well-structured and modular, with separate functions for different tasks.
- The recursive approach is a good fit for exploring paths on a grid.
- The use of sets to store unique destinations and trails is efficient and avoids duplicates.

**Weaknesses**:
- The recursive approach may not be efficient for large inputs due to potential redundant computations.
- The code does not include any error handling or input validation.
- The lack of comments and docstrings makes the code harder to understand and maintain.

**Issues**:
- The `trailhead_destinations` function may revisit the same positions multiple times, leading to redundant computations.
- The `complete_trails` function constructs the complete trails by reversing and concatenating lists, which may be inefficient for long trails.
- The `part1` and `part2` functions iterate over the entire grid, even though many positions may not be trailheads (height 0).

### Day 11: [aoc2024-day11.py](aoc2024-day11.py)

**Score**: 7/10

**Strengths**:
- Modular code with separate functions for different tasks.
- Effective use of dictionaries to optimize Part 2.
- Caching of rule results to avoid redundant computations.

**Weaknesses**:
- Part 1 solution is inefficient for large inputs due to recreating the entire list on each blink.
- No error handling or input validation.

**Issues**:
- The `blink_once` function in Part 1 has a time complexity of O(n^2) due to the `extend` operation on a list.
- The `apply_rule` function could be optimized further by avoiding string conversions for the even-digit case.

### Day 12: [aoc2024-day12.py](aoc2024-day12.py)

**Score**: 7/10

**Strengths**:
- Clear separation of concerns with modular functions for different tasks.
- Effective use of NumPy for array operations and SciPy for connected component labeling.
- Good use of helper functions and visualization tools for debugging.

**Weaknesses**:
- The code could be more concise by using more Pythonic idioms and list comprehensions.
- Some functions like `num_sides_` and `vh_` are quite complex and could benefit from refactoring or better commenting.
- The visualization code is quite verbose and could be separated into a different module.

**Issues**:
- The `num_sides_` function is complex and could be simplified or broken down into smaller functions.
- The `vh_` function is not well-documented, and its purpose is not immediately clear.
- The visualization code is tightly coupled with the solution code, making it harder to maintain or reuse.

### Day 13: [aoc2024-day13.py](aoc2024-day13.py)

**Score**: 8/10

**Strengths**:
- Good use of regular expressions to parse the input data.
- Effective use of NumPy arrays and SymPy for mathematical operations.
- Clear separation of concerns with helper functions for parsing, solving equations, and handling parts 1 and 2.

**Weaknesses**:
- The solve function could be more efficient by checking for trivial solutions before using SymPy's solver.
- The code could benefit from more comments explaining the mathematical approach and the reasoning behind certain steps.

**Issues**:
- The fractional function is unnecessary and could be replaced with a simpler check for integer values.
- The is_int function is not needed if the solve function returns exact solutions.
- The test_solve function is not comprehensive and only tests a single case.

### Day 14: [aoc2024-day14.py](aoc2024-day14.py)

**Score**: 7/10

**Strengths**:
- Clear separation of concerns with separate functions for different tasks.
- Effective use of Python data structures and helper functions.
- Well-structured and readable code with meaningful variable names.

**Weaknesses**:
- The code could be more efficient, especially for Part 2 where it simulates many iterations.
- The Christmas tree detection algorithm could be more efficient.
- The code lacks comments explaining the logic and purpose of some functions.

**Issues**:
- The `is_tree` function checks for a 3x3 block of robots, which may not be the most efficient way to detect a Christmas tree pattern.
- The `part2` function simulates up to 10,000,000 iterations, which could be inefficient for larger inputs.
- The `draw_img` function is not necessary for solving the problem and could be removed.

### Day 15: [aoc2024-day15.py](aoc2024-day15.py)

**Score**: 7/10

**Strengths**:
- Clear separation of concerns with modular code and separate functions for different tasks.
- Effective use of NumPy arrays to represent the warehouse grid.
- Good use of helper functions and classes to encapsulate different aspects of the problem.

**Weaknesses**:
- Some code duplication between Part 1 and Part 2 solutions.
- Lack of comments explaining some of the more complex logic.
- Potential performance issues for very large inputs due to the use of nested loops and set operations.

**Issues**:
- The `move_box_pairs` method in the Warehouse class is quite complex and could benefit from refactoring or additional comments.
- The `extend_frontier` and `advanced_boxes_` methods are also complex and could be simplified or better explained.
- The `valid_part2_grid` function has some code duplication and could be refactored.

### Day 16: [aoc2024-day16.py](aoc2024-day16.py)

**Score**: 8/10

**Strengths**:
- Clear separation of concerns with modular functions for different tasks.
- Effective use of Python data structures like lists, sets, and dictionaries.
- Good use of helper functions and functional programming techniques.
- Well-structured and readable code with meaningful variable names and comments.

**Weaknesses**:
- The code could be more concise by using more Pythonic idioms like list comprehensions and generator expressions.
- The memory usage for reconstructing all best paths in part 2 could be improved.

**Issues**:
- The `reconstruct_paths` function in `solve_maze_paths` could be optimized to avoid reconstructing duplicate paths.
- The `reconstruct_points` function in `solve_maze_points` could be simplified by using a set comprehension or generator expression.

### Day 17: [aoc2024-day17.py](aoc2024-day17.py)

**Score**: 7/10

**Strengths**:
- Clear separation of concerns with functions for parsing, execution, and output formatting.
- Effective use of Python data structures like dictionaries for registers.
- Good use of helper functions like combo_ and reg_str.

**Weaknesses**:
- Lack of comments explaining the program execution logic and the depth-first search approach.
- Potential inefficiency in the depth-first search, as it tries all possible values of register A.

**Issues**:
- The dfs function could be optimized by using bitmasks or other techniques to avoid trying all possible values of register A.
- The execute_program function could be made more concise by using a dictionary or function lookup for opcodes instead of a long if-elif chain.

### Day 18: [aoc2024-day18.py](aoc2024-day18.py)

**Score**: 8/10

**Strengths**:
- Clear separation of concerns with modular functions for different tasks.
- Effective use of Python data structures (lists, tuples) and built-in functions.
- Good use of helper functions (e.g. reconstruct_path, grid_to_string).
- Well-structured and readable code with meaningful variable names and comments.

**Weaknesses**:
- The Uniform Cost Search algorithm could be optimized further for better performance.
- The code for part 2 could be more concise and efficient.
- The test cases are limited and could be more comprehensive.

**Issues**:
- The solve_grid function could be optimized to avoid reconstructing the entire path for each iteration.
- The part2 function has some redundant code and could be refactored for better readability.

### Day 19: [aoc2024-day19.py](aoc2024-day19.py)

**Score**: 7/10

**Strengths**:
- The code is well-structured with separate functions for different tasks.
- The use of lru_cache for memoization is an effective optimization.
- The helper functions like lines_to_towels_and_designs and test1 are well-designed.

**Weaknesses**:
- The global variable global_towels is not ideal and could be avoided by passing towels as an argument.
- The dfs_all function could be simplified by returning early when a match is found.
- The code could benefit from more comments explaining the logic and approach.

**Issues**:
- The dfs_all function has a depth parameter that is not used.
- The num_valid_designs function creates a global variable and then calls dfs_all, which is not very modular.
- The test1 function hardcodes the test cases instead of reading them from the input.

### Day 20: [aoc2024-day20.py](aoc2024-day20.py)

**Score**: 8/10

**Strengths**:
- The code is well-structured with separate functions for different tasks.
- It uses appropriate data structures like dictionaries and sets efficiently.
- The uniform cost search algorithm is a good choice for finding the shortest path.

**Weaknesses**:
- The code for identifying cheats in part 2 could be more efficient, as it considers all pairs of points on the path.
- The code could benefit from more comments explaining the logic behind the cheat identification algorithms.

**Issues**:
- The improvements2_ function could be optimized by avoiding unnecessary computations for pairs of points that are too far apart to benefit from a cheat.
- The cheat_len_ function could be simplified by using the built-in max function instead of separate abs calls.

### Day 21: [aoc2024-day21.py](aoc2024-day21.py)

**Score**: 8/10

**Strengths**:
- Clear separation of concerns with modular functions for different tasks.
- Effective use of Python data structures (lists, dictionaries) and helper functions.
- Caching of intermediate results to improve efficiency for larger inputs.

**Weaknesses**:
- The code could benefit from more comments explaining the logic and purpose of certain functions.
- The use of nested loops and recursion could potentially lead to inefficiencies for extremely large inputs, although this is unlikely to be an issue for the given problem constraints.

**Issues**:

### Day 22: [aoc2024-day22.py](aoc2024-day22.py)

**Score**: 8/10

**Strengths**:
- Clear separation of concerns with separate functions for generating secret numbers, calculating prices, and finding optimal sequences.
- Effective use of Python data structures like lists and tuples to represent prices and sequences.
- Good use of helper functions like mix_prune and secret_number_ to encapsulate the secret number generation logic.

**Weaknesses**:
- The max_num_bananas_ function could be optimized to avoid checking all possible sequences, as many sequences are unlikely to be optimal.
- The code could benefit from more comments explaining the logic behind the secret number generation and price change sequence optimization.

**Issues**:
- The max_num_bananas_ function has a nested loop that could become inefficient for larger inputs.
- The Sequence class could be simplified by using a tuple or list instead of a custom class.

### Day 23: [aoc2024-day23.py](aoc2024-day23.py)

**Score**: 8/10

**Strengths**:
- Clear separation of concerns with modular functions.
- Effective use of Python data structures like sets and dictionaries.
- Good use of helper functions and graph algorithms.
- Well-structured and readable code with meaningful variable names.

**Weaknesses**:
- The Bron-Kerbosch algorithm implementation could be more efficient, especially for large graphs.
- The code could benefit from more comments explaining the algorithms and data structures used.

**Issues**:
- The bron_kerbosch and bron_kerbosch_with_pivot functions have some code duplication and could be refactored.
- The triplets_ function has a nested loop that could be optimized for better performance.

### Day 24: [aoc2024-day24.py](aoc2024-day24.py)

**Score**: 8/10

**Strengths**:
- Clear separation of concerns with modular functions for parsing, evaluating, and solving each part.
- Effective use of Python data structures (dictionaries, sets) to represent wire values and connections.
- Good use of helper functions and list comprehensions.
- Well-commented code explaining the problem, approach, and ripple-carry adder rules.

**Weaknesses**:
- The ripple-carry adder rules and their implementation could be more concise and easier to understand.
- The code could benefit from more descriptive variable names in some places.
- The lack of test cases makes it harder to verify the correctness of the solution.

**Issues**:
- The `ripple_carry_adder_violations` function is quite complex and could be refactored for better readability.
- The `evaluate_wires` function has a nested loop that could potentially be optimized for better performance.

### Day 25: [aoc2024-day25.py](aoc2024-day25.py)

**Score**: 7/10

**Strengths**:
- The code is modular with separate functions for different tasks.
- It uses Python data structures like lists and tuples effectively.
- The heights_is_key_ function is a clever way to convert the schematics into heights.

**Weaknesses**:
- The is_fits function could be made more concise using Python's built-in zip and all functions.
- The num_fits_ function could be simplified using a generator expression or list comprehension.
- The part2 function is just a placeholder and does not provide a solution.

**Issues**:
- The keys_and_locks_ function has some redundant code that could be refactored.
- The is_fits function could be inlined into num_fits_ for better efficiency.
- The part2 function needs to be implemented to solve the second part of the problem.

